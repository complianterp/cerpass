namespace cerpass.db;

using cerpass.db :: masterdata.MODULE;
using cerpass.db :: masterdata.SUB_MODULE;
using cerpass.db :: masterdata.PROCESSES;
using cerpass.db :: masterdata.SUB_PROCESSES;
using cerpass.db :: masterdata.CUSTOMERS;
using cerpass.db :: masterdata.LOGICAL_SYSTEMS;
using cerpass.db :: masterdata.USERS;
using cerpass.db :: masterdata.RULE_SET;
using cerpass.db :: masterdata.ACTIVITY;
using cerpass.db :: masterdata.ACT_TCODE; //In Use
using cerpass.db :: masterdata.ACT_AUTH; //In Use
using cerpass.db :: masterdata.TESTS;
using cerpass.db :: masterdata.TEST_ACTIVITY;
using cerpass.db :: masterdata.RISKS;
using cerpass.db :: masterdata.RISK_RATING;
using cerpass.db :: masterdata.RISK_TEST;
using cerpass.db :: masterdata.BUSINESS_CONTROL;
using cerpass.db :: masterdata.TESTS_BUSINESS_CONTROL;
using cerpass.db :: sapdata.TSTC;
using cerpass.db :: sapdata.TOBJT;
using cerpass.db :: sapdata.UST12; //In Use
using cerpass.db :: sapdata.UST10S; //In Use
using cerpass.db :: sapdata.UST10C; //In Use
using cerpass.db :: sapdata.USR10;
using cerpass.db :: sapdata.AGR_1016; //In Use
using cerpass.db :: sapdata.UST04; //In Use
using cerpass.db :: sapdata.AGR_AGRS; //In Use
using cerpass.db :: sapdata.USR02; //In Use

context scan {

    //SCAN AUTH ---------------------------------------------------------------------------------------------------------------------------------------------


    //SCAN AUTH PREP-----------------------------------------------------------------------------------------
		/*View to add an extra VON column into UST12 which displays only those values listed left of
 		the first * found the VON string.  The * is included as well.
 		
 		This is required to cater for those older versions of SAP which allowed invalid combinations of
 		wild cards that would cause issues with the fuzzy matching logic.*/

    view SCAN1_AUTH_P00_UST12_CONVERT_P01 as
        select from UST12 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            left("VON", (locate("VON", '*'))) "VON_LEFT_OF_STAR",
            A1.BIS
        }
        where
                OBJCT <>   'TSTC'
            and VON   like '%*%'
    union
        select from UST12 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON "VON_LEFT_OF_STAR",
            A1.BIS
        }
        where
                OBJCT <>       'TSTC'
            and VON   not like '%*%';

    //------------------------------------------------------------------------------------------------------
		/*View to add an extra BIS column into UST12 which displays only those values listed left of
 		the first * found the BIS string.  The * is included as well.
 		
 		This is required to cater for those older versions of SAP which allowed invalid combinations of
 		wild cards that would cause issues with the fuzzy matching logic.*/

    view SCAN1_AUTH_P00_UST12_CONVERT_P02 as
        select from SCAN1_AUTH_P00_UST12_CONVERT_P01 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.BIS,
            left("BIS", (locate("BIS", '*'))) "BIS_LEFT_OF_STAR"
        }
        where
            BIS like '%*%'
    union
        select from SCAN1_AUTH_P00_UST12_CONVERT_P01 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.BIS,
            A1.BIS "BIS_LEFT_OF_STAR"
        }
        where
               BIS not like '%*%'
            or BIS is       null;

    //-------------------------------------------------------------------
		/*View to add an extra VON column into UST12 where all * values have been replaces with a % */
		/*This is required to make the fuzzy matching logic to work*/

    view SCAN1_AUTH_P00_UST12_CONVERT_P03 as
        select from SCAN1_AUTH_P00_UST12_CONVERT_P02 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            replace("VON_LEFT_OF_STAR", '*', '%') "VON_WILD_CARD",
            A1.BIS,
            A1.BIS_LEFT_OF_STAR
        };

    //------------------------------------------------------------------------------------------------------
		/*View to add an extra AUTH_VALUES_VON column into ACT_AUTH where all * values have been replaces with a %*/
		/*This is required to make the fuzzy matching logic to work*/

    view SCAN1_AUTH_P00_ACT_AUTH_CONVERT as
        select from ACT_AUTH as A2
        {
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            A2.AUTH_VALUES_VON,
            replace("AUTH_VALUES_VON", '*', '%') "AUTH_VALUES_VON_WILD_CARD",
            A2.AUTH_VALUES_BIS,
            A2.LOGIC_OPERATOR,
            A2.ACTIVE
        }
        where
            ACTIVE = true;

    //------------------------------------------------------------------------------------------------------


    //SCAN AUTH SCAN-------------------------------------------------------------------------------------------------------------------------------------------------


    //------------------------------------------------------------------------------------------------------
		/*View produces a list of matches between a record in ACT_AUTH and UST12. */

			/*UST12 and ACT_AUTH are joined on FIELD in UST12 and FIELD in ACT_AUTH as well
     		as OBJCT in UST12 and OBJECT in ACT_AUTH.  Different where clauses are then used
     		in each select in the UNION to produce different types of matches required*/

			/*This is a UNION that combines 3 different queries*/

			/*This select in the UNION produces all matches that occur from a range values and direct matches.
     		The where clause takes the AUTH_VALUES_VON value from SCAN1_AUTH_P00_ACT_AUTH_CONVERT and checks
     		if it between VON_LEFT_OF_STAR and BIS_LEFT_OF_STAR in SCAN1_AUTH_P00_UST12_CONVERT_P03 or,
     		if the VON_LEFT_OF_STAR value from SCAN1_AUTH_P00_UST12_CONVERT_P03 is between AUTH_VALUES_VON and
     		AUTH_VALUES_BIS in SCAN1_AUTH_P00_ACT_AUTH_CONVERT this produces all range matches.
     		The where clause also checks if AUTH_VALUES_VON in SCAN1_AUTH_P00_ACT_AUTH_CONVERT is equal to
     		VON_LEFT_OF_STAR is SCAN1_AUTH_P00_UST12_CONVERT_P03 producing all the direct value matches.*/

    view SCAN1_AUTH_P01_ALL_MATCHES as
        select from SCAN1_AUTH_P00_UST12_CONVERT_P03 as A1
        join (
                    SCAN1_AUTH_P00_ACT_AUTH_CONVERT as A2
        )                                                  on
                A1.FIELD = A2."AUTH_FIELD"
            and A1.OBJCT = A2."OBJECT"
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,            //This is the converted field to fix the multiple wildcard issues
            A1."VON_WILD_CARD",             //This is the converted VON field for the fuzzy matching
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,            //This is the converted field to fix the multiple wildcard issues
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            A2.AUTH_VALUES_VON,
            A2."AUTH_VALUES_VON_WILD_CARD", //This is the converted VON field for the fuzzy matching
            A2.AUTH_VALUES_BIS,
            A2."LOGIC_OPERATOR"
        }
        where
            (
                (
                    (A2."AUTH_VALUES_VON")  between A1."VON_LEFT_OF_STAR" and A1."BIS_LEFT_OF_STAR"
                )
            )
            or (
                (
                    (A1."VON_LEFT_OF_STAR") between A2."AUTH_VALUES_VON" and A2."AUTH_VALUES_BIS"
                )
            )
            or (
                (
                    A2.AUTH_VALUES_VON      =       A1.VON_LEFT_OF_STAR
                )
            )
    union

    		 /*This select in the UNION produces a list of matches where the VON value in UST12 contains a wildcard value “*”
        	and where the BIS value for UST12 is null removing any ranges from the list of matches.  The Where clause then checks
        	and returns matches where the AUTH_VALUES_VON value in SCAN1_AUTH_P00_ACT_AUTH_CONVERT is like VON_WILD_CARD (the converted VON field)
        	in SCAN1_AUTH_P00_UST12_CONVERT_P03 producing all fuzzy matching records where a wildcard is used in UST12.

        	The where clause also checks if the VON value in UST12 is equal to “*” returning all matches that occur due to the VON value in UST12
        	being listed as “*” */

        select from SCAN1_AUTH_P00_UST12_CONVERT_P03 as A1
        join (
                    SCAN1_AUTH_P00_ACT_AUTH_CONVERT as A2
        )                                                  on
                A1.FIELD = A2.AUTH_FIELD
            and A1.OBJCT = A2.OBJECT
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.VON_WILD_CARD,
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            A2.AUTH_VALUES_VON,
            A2.AUTH_VALUES_VON_WILD_CARD,
            A2.AUTH_VALUES_BIS,
            A2."LOGIC_OPERATOR"
        }
        where
            (
                    A1.VON             like '%*%'
                and A1.BIS             is   null
                and A2.AUTH_VALUES_VON like A1.VON_WILD_CARD
            )
            or (
                    A1.VON             =    '*'
            )
    union

        	/*This select in the UNION produces a list of matches where the VON value in ACT_AUTH contains a wildcard value “*”
         	and where the BIS value for ACT_AUTH is null removing any ranges from the list of matches.  The Where clause then checks
         	and returns matches where the VON_LEFT_OF_STAR value in SCAN1_AUTH_P00_UST12_CONVERT_P03 is like AUTH_VALUES_VON_WILD_CARD
         	(the converted VON field) in SCAN1_AUTH_P00_ACT_AUTH_CONVERT producing all fuzzy matching records where a wildcard is used in ACT_AUTH.

         	The where clause also checks if the VON value in ACT_AUTH is equal to “*” returning all matches that occur due to the VON value in ACT_AUTH
         	being listed as “*” */


        select from SCAN1_AUTH_P00_ACT_AUTH_CONVERT as A2
        join (
                    SCAN1_AUTH_P00_UST12_CONVERT_P03 as A1
        )                                                  on
                A2.AUTH_FIELD = A1.FIELD
            and A2.OBJECT     = A1.OBJCT
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.VON_WILD_CARD,
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            A2.AUTH_VALUES_VON,
            A2.AUTH_VALUES_VON_WILD_CARD,
            A2.AUTH_VALUES_BIS,
            A2."LOGIC_OPERATOR"
        }
        where
            (
                    A2.AUTH_VALUES_VON  like '%*%'
                and A2.AUTH_VALUES_BIS  is   null
                and A1.VON_LEFT_OF_STAR like A2.AUTH_VALUES_VON_WILD_CARD
            )
            or (
                    A2.AUTH_VALUES_VON  =    '*'
            );

    //------------------------------------------------------------------------------------------------------

			/*View produces a list of ACT_AUTH values where the values have been grouped by ACT_ID, GROUP_NUMBER, OBJECT,
     		AUTH_FIELD and AUTH_VALUES_VON to produce a unique list of values and provide a count of VON values in ACT_AUTH.
     		The where clause then limits the records to only those records that have a local operator of AND and are set to active.

     		This view is required as the count field produces the field COUNT_OF_AUTH_VALUES which provides a value to compare the AUTH matches to.
     		This same count process is applied to the records produced from SCAN1_AUTH_P01_ALL_MATCHES which then produces a COUNT_OF_AUTH_VALUES field for each AUTH.
     		These tables are then joined on COUNT_OF_AUTH_VALUES, AUTH_FIELD, OBJECT, GROUP_NUMBER and ACT_ID to produce a list of matches where the
     		correct number of values are true for an AUTH. This caters for the AND logical operator matches at a value level.*/

    view SCAN1_AUTH_P02_AUTH_AND_VALUE_COUNT as
        select from ACT_AUTH as A2
        {
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            count(A2.AUTH_VALUES_VON) as COUNT_OF_AUTH_VALUES,
            A2.LOGIC_OPERATOR,
            A2.ACTIVE
        }
        group by
            A2.ACT_ID,
            A2.GROUP_NUMBER,
            A2.OBJECT,
            A2.AUTH_FIELD,
            A2.LOGIC_OPERATOR,
            A2.ACTIVE
        having
            (
                (
                    (A2.LOGIC_OPERATOR) = '1'
                )
                and (
                    (A2.ACTIVE)         = true
                )
            );

    //------------------------------------------------------------------------------------------------------
			/*View produces a list of SCAN1_AUTH_P01_ALL_MATCHES values where the values have been grouped by OBJCT, AUTH,
     		FIELD, VON, BIS, ACT_ID, GROUP_NUMBER, OBJECT, AUTH_FIELD and LOGIC_OPERATOR to produce a unique list of
     		values and provide a count of values matches in SCAN1_AUTH_P01_ALL_MATCHES.  The where clause then limits the records
     		to only those records set to active.

     		This view is required as the count field produces the field COUNT_OF_AUTH_VALUES which provides a value to compare the ACT_AUTH
     		matches to.  This same count process is applied to the records produced from ACT_AUTH which then produces a COUNT_OF_AUTH_VALUES
     		field for each AUTH.  These tables are then joined on COUNT_OF_AUTH_VALUES, AUTH_FIELD, OBJECT, GROUP_NUMBER and ACT_ID to produce
     		a list of matches where the correct number of values are true for an AUTH. This caters for the AND logical operator matches at a value level.*/

    /*view SCAN1_AUTH_P03_AND_VALUE_COUNT as
        select from SCAN1_AUTH_P01_ALL_MATCHES as P1
        {
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            P1.VON,
            P1.BIS,
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            count(P1.AUTH_VALUES_VON) as COUNT_OF_AUTH_VALUES,
            P1.LOGIC_OPERATOR
        }
        group by
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            P1.VON,
            P1.BIS,
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            P1.LOGIC_OPERATOR
        having
            (
                (
                    (P1.LOGIC_OPERATOR) = 1
                )
            );*/

    view SCAN1_AUTH_P03_AND_VALUE_COUNT as
        select from SCAN1_AUTH_P01_ALL_MATCHES as P1
        {
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            //P1.VON,
            //P1.BIS,
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            count(P1.AUTH_VALUES_VON) as COUNT_OF_AUTH_VALUES,
            P1.LOGIC_OPERATOR
        }
        group by
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            //P1.VON,
            //P1.BIS,
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            P1.LOGIC_OPERATOR
        having
            (
                (
                    (P1.LOGIC_OPERATOR) = 1
                )
            );

    //------------------------------------------------------------------------------------------------------
			/*This view joins SCAN1_AUTH_P02_AUTH_AND_VALUE_COUNT and SCAN1_AUTH_P03_AND_VALUE_COUNT on COUNT_OF_AUTH_VALUES,
     		AUTH_FIELD, OBJECT, GROUP_NUMBER and ACT_ID.  The join on COUNT_OF_AUTH_VALUES between the two tables
     		ensures only AND match records are produces if they match all of the values specified in ACT_AUTH.
     		By producing the COUNT_OF_AUTH_VALUES in both tables it provides a commonality between the two tables to
     		compare and produce only true AND value matches. */

    view SCAN1_AUTH_P04_AND_VALUE_TRUE as
        select from SCAN1_AUTH_P03_AND_VALUE_COUNT as P3
        join (
                    SCAN1_AUTH_P02_AUTH_AND_VALUE_COUNT as P2
        )                                                     on
                P2.COUNT_OF_AUTH_VALUES = P3.COUNT_OF_AUTH_VALUES
            and P2.AUTH_FIELD           = P3.AUTH_FIELD
            and P2.OBJECT               = P3.OBJECT
            and P2.GROUP_NUMBER         = P3.GROUP_NUMBER
            and P2.ACT_ID               = P3.ACT_ID
        {
            P3.OBJCT,
            P3.AUTH,
            P3.FIELD,
            //P3.VON,
            //P3.BIS,
            P3.ACT_ID,
            P3.GROUP_NUMBER,
            P3.OBJECT,
            P3.AUTH_FIELD,
            P2.COUNT_OF_AUTH_VALUES,
            P3.LOGIC_OPERATOR
        };

    //------------------------------------------------------------------------------------------------------
		/*This view produces all value matches where the logical operator is OR.  This is any record in
   		SCAN1_AUTH_P01_ALL_MATCHES where the logical operator is 2.*/

    view SCAN1_AUTH_P05_OR_VALUE_TRUE as
        select from SCAN1_AUTH_P01_ALL_MATCHES as P1
        {
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            //P1.VON,
            //P1.BIS,
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            P1.AUTH_VALUES_VON,
            P1.AUTH_VALUES_BIS,
            P1.LOGIC_OPERATOR
        }
        where
            (
                (
                    (P1.LOGIC_OPERATOR) = '2'
                )
            );

    //------------------------------------------------------------------------------------------------------
		/*This view is a UNION of SCAN1_AUTH_P04_AND_VALUE_TRUE and SCAN1_AUTH_P05_OR_VALUE_TRUE to produce a full list of value matches.*/
	view SCAN1_AUTH_P06_UNION_VALUE_TRUE as
		select from SCAN1_AUTH_P04_AND_VALUE_TRUE as P4
			distinct{
			P4.OBJCT,
            P4.AUTH,
            P4.FIELD,
            //P4.VON,
            //P4.BIS,
            P4.ACT_ID,
            P4.GROUP_NUMBER,
            P4.OBJECT,
            P4.AUTH_FIELD,
            P4.LOGIC_OPERATOR
			}
   union
		select from SCAN1_AUTH_P05_OR_VALUE_TRUE as P5
		distinct{
            P5.OBJCT,
            P5.AUTH,
            P5.FIELD,
            //P5.VON,
            //P5.BIS,
            P5.ACT_ID,
            P5.GROUP_NUMBER,
            P5.OBJECT,
            P5.AUTH_FIELD,
            P5.LOGIC_OPERATOR
		};

    //------------------------------------------------------------------------------------------------------
		/*This view produces a list of distinct AUTH_FIELD values from ACT_AUTH to then perform a count on the AUTH_FIELD field.*/

    //------------------------------------------------------------------------------------------------------

    view SCAN1_AUTH_P07_AUTH_FIELD as
        select from ACT_AUTH distinct
        {
            ACT_AUTH.ACT_ID,
            ACT_AUTH.GROUP_NUMBER,
            ACT_AUTH.OBJECT,
            ACT_AUTH.AUTH_FIELD,
            ACT_AUTH.LOGIC_OPERATOR,
            ACT_AUTH.ACTIVE
        }
        where
            (
                (
                    (ACT_AUTH.ACTIVE) = true
                )
            );

    //------------------------------------------------------------------------------------------------------
			/*This view performs a count on AUTH_FIELD from the unique list of AUTH_FIELD values produces in SCAN1_AUTH_P07_AUTH_FIELD.
     	
     		This view is required as the count field produces the field COUNT_OF_AUTH_FIELD which provides a value to compare the AUTH matches to.
     		The same count process is applied to the records produced from SCAN1_AUTH_P09_MATCH_FIELD which also produces COUNT_OF_AUTH_FIELD for
     		each AUTH value match. These two tables are then joined on COUNT_OF_AUTH_FIELD, OBJECT, GROUP_NUMBER and ACT_ID to produce a list of
     		matches were the correct number of fields are true for an AUTH.  This caters for matches that may occur due to there being multiple field
     		within the authorisation object.*/


    view SCAN1_AUTH_P08_AUTH_FIELD_COUNT as
        select from SCAN1_AUTH_P07_AUTH_FIELD as P7
        {
            P7.ACT_ID,
            P7.GROUP_NUMBER,
            P7.OBJECT,
            count(P7.AUTH_FIELD) as COUNT_OF_AUTH_FIELD,
            P7.ACTIVE
        }
        group by
            P7.ACT_ID,
            P7.GROUP_NUMBER,
            P7.OBJECT,
            P7.ACTIVE;

    //------------------------------------------------------------------------------------------------------
		/*This view produces a list of distinct AUTH_FIELD values from SCAN_P06_UNION_VALUE_TRUE to then perform a count on the AUTH_FIELD field.*/


    view SCAN1_AUTH_P09_MATCH_FIELD as
        select from SCAN1_AUTH_P06_UNION_VALUE_TRUE distinct
        {
            OBJCT,
            AUTH,
            FIELD,
            ACT_ID,
            GROUP_NUMBER,
            OBJECT,
            AUTH_FIELD
        };

    //------------------------------------------------------------------------------------------------------
			/*This view performs a count on AUTH_FIELD from the unique list of AUTH_FIELD values produces in SCAN1_AUTH_P09_MATCH_FIELD.
     	
     		This view is required as the count field produces the field COUNT_OF_AUTH_FIELD which provides a value to compare the AUTH matches to.
     		The same count process is applied to the records produced from SCAN1_AUTH_P07_AUTH_FIELD which also produces COUNT_OF_AUTH_FIELD for
     		each AUTH value match. These two tables are then joined on COUNT_OF_AUTH_FIELD, OBJECT, GROUP_NUMBER and ACT_ID to produce a list of
     		matches were the correct number of fields are true for an AUTH.  This caters for matches that may occur due to there being multiple field
     		within the authorisation object.*/

    view SCAN1_AUTH_P10_MATCH_FIELD_COUNT as
        select from SCAN1_AUTH_P09_MATCH_FIELD as P9
        {
            P9.OBJCT,
            P9.AUTH,
            P9.ACT_ID,
            P9.GROUP_NUMBER,
            P9.OBJECT,
            count(P9.AUTH_FIELD) as COUNT_OF_AUTH_FIELD
        }
        group by
            P9.OBJCT,
            P9.AUTH,
            P9.ACT_ID,
            P9.GROUP_NUMBER,
            P9.OBJECT;

    //------------------------------------------------------------------------------------------------------
			/*This view joins SCAN1_AUTH_P08_AUTH_FIELD_COUNT and SCAN1_AUTH_P10_MATCH_FIELD_COUNT on COUNT_OF_AUTH_FIELD,
     		OBJECT, GROUP_NUMBER and ACT_ID.  The join on COUNT_OF_AUTH_FIELD between the two tables
     		ensures only matches are made where all fields in the activity occur in the auth.
     		By producing the COUNT_OF_AUTH_FIELD in both tables it provides a commonality between the two tables to
     		compare and produce only true FIELD matches. */

    view SCAN1_AUTH_P11_MATCH_FIELD_TRUE as
        select from SCAN1_AUTH_P10_MATCH_FIELD_COUNT as P10
        join (
                    SCAN1_AUTH_P08_AUTH_FIELD_COUNT as P8
        )                                                   on
                P8.COUNT_OF_AUTH_FIELD = P10.COUNT_OF_AUTH_FIELD
            and P8.OBJECT              = P10.OBJECT
            and P8.GROUP_NUMBER        = P10.GROUP_NUMBER
            and P8.ACT_ID              = P10.ACT_ID
        {
            P10.OBJCT,
            P10.AUTH,
            P10.ACT_ID,
            P10.GROUP_NUMBER,
            P10.COUNT_OF_AUTH_FIELD
        };


    //------------------------------------------------------------------------------------------------------
		/*This view produces a list of distinct AUTH_OBJECT values from ACT_AUTH to then perform a count on the AUTH_OBJECT field.*/

    //------------------------------------------------------------------------------------------------------

    view SCAN1_AUTH_P12_AUTH_OBJCT as
        select from ACT_AUTH distinct
        {
            ACT_AUTH.ACT_ID,
            ACT_AUTH.GROUP_NUMBER,
            ACT_AUTH.OBJECT,
            ACT_AUTH.ACTIVE
        }
        where
            (
                (
                    (ACT_AUTH.ACTIVE) = true
                )
            );

    //------------------------------------------------------------------------------------------------------
			/*This view performs a count on AUTH_OBJECT from the unique list of AUTH_OBJECT values produces in SCAN1_AUTH_P00_AUTH_OBJECT.
     	
     		This view is required as the count field produces the field COUNT_OF_AUTH_OBJCT which provides a value to compare the AUTH matches to.
     		The same count process is applied to the records produced from SCAN1_AUTH_P00_MATCH_OBJECT which also produces COUNT_OF_AUTH_OBJCT for
     		each AUTH value match. These two tables are then joined on COUNT_OF_AUTH_OBJCT, GROUP_NUMBER and ACT_ID to produce a list of
     		matches were the correct number of objects are true for an AUTH.  This caters for matches that may occur due to there being multiple objects
     		within the group.*/


    view SCAN1_AUTH_P13_AUTH_OBJCT_COUNT as
        select from SCAN1_AUTH_P12_AUTH_OBJCT as P12
        {
            P12.ACT_ID,
            P12.GROUP_NUMBER,
            count(P12.OBJECT) as COUNT_OF_AUTH_OBJCT,
            P12.ACTIVE
        }
        group by
            P12.ACT_ID,
            P12.GROUP_NUMBER,
            P12.ACTIVE;

    //------------------------------------------------------------------------------------------------------
		/*This view produces a list of distinct OBJCT values from SCAN1_AUTH_P11_MATCH_FIELD_TRUE to then perform a count on the OBJCT field.*/


    view SCAN1_AUTH_P14_MATCH_OBJCT as
        select from SCAN1_AUTH_P11_MATCH_FIELD_TRUE distinct
        {
            AUTH,
            ACT_ID,
            GROUP_NUMBER,
            OBJCT
        };

    //------------------------------------------------------------------------------------------------------
			/*This view performs a count on OBJCT from the unique list of OBJCT values produces in SCAN1_AUTH_P14_MATCH_OBJCT.
     	
     		This view is required as the count field produces the field COUNT_OF_AUTH_OBJCT which provides a value to compare the AUTH matches to.
     		The same count process is applied to the records produced from SCAN1_AUTH_P12_AUTH_OBJCT which also produces COUNT_OF_AUTH_OBJCT for
     		each AUTH value match. These two tables are then joined on COUNT_OF_AUTH_OBJCT, GROUP_NUMBER and ACT_ID to produce a list of
     		matches were the correct number of objects are true for an AUTH.  This caters for matches that may occur due to there being multiple objects
     		within the one group.*/

    view SCAN1_AUTH_P15_MATCH_OBJCT_COUNT as
        select from SCAN1_AUTH_P14_MATCH_OBJCT as P14
        {
            P14.AUTH,
            P14.ACT_ID,
            P14.GROUP_NUMBER,
            count(P14.OBJCT) as COUNT_OF_AUTH_OBJCT
        }
        group by
            P14.AUTH,
            P14.ACT_ID,
            P14.GROUP_NUMBER;



    //------------------------------------------------------------------------------------------------------
			/*This view joins SCAN1_AUTH_P08_AUTH_FIELD_COUNT and SCAN1_AUTH_P10_MATCH_FIELD_COUNT on COUNT_OF_AUTH_FIELD,
     		OBJECT, GROUP_NUMBER and ACT_ID.  The join on COUNT_OF_AUTH_FIELD between the two tables
     		ensures only matches are made where all fields in the activity occur in the auth.
     		By producing the COUNT_OF_AUTH_FIELD in both tables it provides a commonality between the two tables to
     		compare and produce only true FIELD matches. */

    view SCAN1_AUTH_P16_MATCH_OBJCT_TRUE as
        select from SCAN1_AUTH_P15_MATCH_OBJCT_COUNT as P15
        join (
                    SCAN1_AUTH_P13_AUTH_OBJCT_COUNT as P13
        )                                                   on
                P13.COUNT_OF_AUTH_OBJCT = P15.COUNT_OF_AUTH_OBJCT
            and P13.GROUP_NUMBER        = P15.GROUP_NUMBER
            and P13.ACT_ID              = P15.ACT_ID
        {
            P15.AUTH,
            P15.ACT_ID,
            P15.GROUP_NUMBER,
            P15.COUNT_OF_AUTH_OBJCT
        };


    //------------------------------------------------------------------------------------------------------
		/*This view joins SCAN1_AUTH_P01_ALL_MATCHES, SCAN1_AUTH_P06_UNION_VALUE_TRUE and SCAN1_AUTH_P11_MATCH_FIELD_TRUE on OBJCT,
    	AUTH, ACT_ID and GROUP_NU1MBER.  This provides the dill down detail for Auths for Scan 1 showing what values cause the matches to occur.
    	This view uses the true field auth matches from SCAN1_AUTH_P11_MATCH_FIELD_TRUE and the true values matches from SCAN1_AUTH_P06_UNION_VALUE_TRUE
    	to connect back to SCAN1_AUTH_P01_ALL_MATCHES which shows all the individual matching records.*/


    view SCAN1_AUTH_P17_FULL as
        select from SCAN1_AUTH_P01_ALL_MATCHES as P1
        join (
                    SCAN1_AUTH_P06_UNION_VALUE_TRUE as P6
        )                                                  on
                P1.OBJCT        = P6.OBJCT
            and P1.AUTH         = P6.AUTH
            and P1.ACT_ID       = P6.ACT_ID
            and P1.GROUP_NUMBER = P6.GROUP_NUMBER
        join (
                    SCAN1_AUTH_P11_MATCH_FIELD_TRUE as P11
        )                                                  on
                P6.OBJCT        = P11.OBJCT
            and P6.AUTH         = P11.AUTH
            and P6.ACT_ID       = P11.ACT_ID
            and P6.GROUP_NUMBER = P11.GROUP_NUMBER
        distinct
        {
            P1.OBJCT,
            P1.AUTH,
            P1.FIELD,
            P1.VON,
            P1.VON_LEFT_OF_STAR,            //This is the converted field to fix the multiple wildcard issues
            P1."VON_WILD_CARD",             //This is the converted VON field for the fuzzy matching
            P1.BIS,
            P1.BIS_LEFT_OF_STAR,            //This is the converted field to fix the multiple wildcard issues
            P1.ACT_ID,
            P1.GROUP_NUMBER,
            P1.OBJECT,
            P1.AUTH_FIELD,
            P1.AUTH_VALUES_VON,
            P1."AUTH_VALUES_VON_WILD_CARD", //This is the converted VON field for the fuzzy matching
            P1.AUTH_VALUES_BIS,
            P1.LOGIC_OPERATOR
        };


    //------------------------------------------------------------------------------------------------------

    //SCAN AUTH TO PROFILE-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
		/*This view joins the true Auth matches from SCAN1_AUTH_P11_MATCH_FIELD_TRUE to the Auths corresponding Single Profile in UST10S.*/

    view SCAN1_AUTH_P18_SINGLE_PROF as
        select from SCAN1_AUTH_P11_MATCH_FIELD_TRUE as P11
        join (
                    UST10S as UST10S
        )                                                  on
                P11.OBJCT = UST10S.OBJCT
            and P11.AUTH  = UST10S.AUTH
        distinct
        {
            UST10S.PROFN"SINGLE_PROFN",
            P11.OBJCT,
            P11.AUTH,
            P11.ACT_ID,
            P11.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------
		/*This view joins UST10C to the results of SCAN1_AUTH_P13 producing the list of composite profile matches.*/

    view SCAN1_AUTH_P19_COMP_PROF as
        select from SCAN1_AUTH_P18_SINGLE_PROF as P18
        join (
                    UST10C as UST10C
        )                                             on
            P18.SINGLE_PROFN = UST10C.SUBPROF
        distinct
        {
            UST10C.PROFN "COMP_PROFN",
            P18.SINGLE_PROFN,
            P18.OBJCT,
            P18.AUTH,
            P18.ACT_ID,
            P18.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------
		/*This view is a Union of SCAN1_AUTH_P13 and SCAN1_AUTH_P14 creating a single output table for auth profile matches with a column identifying the type of profile.*/
	view SCAN1_AUTH_P20_PROF_UNION as
	select from SCAN1_AUTH_P18_SINGLE_PROF as P18
	    {
	    	P18.SINGLE_PROFN "PROFN",
	    	'SINGLE_PROF' "TYPE",
            P18.OBJCT,
            P18.AUTH,
            P18.ACT_ID,
            P18.GROUP_NUMBER
	    }
UNION

	select from SCAN1_AUTH_P19_COMP_PROF as P19
		{
			P19.COMP_PROFN "PROFN",
	    	'COMP_PROF' "TYPE",
            P19.OBJCT,
            P19.AUTH,
            P19.ACT_ID,
            P19.GROUP_NUMBER
		};


    //------------------------------------------------------------------------------------------------------
		/*This view shows the User Activity Auth matches.  This is done by joining SCAN1_AUTH_P15 to UST04.  The user type is also added into the view by joining UST04 and USR02.*/

    view SCAN1_AUTH_P21_USERS as
        select from SCAN1_AUTH_P20_PROF_UNION as P15
         join (
                    UST04 as UST04
        )                                             on
            P15.PROFN = UST04.PROFILE
         join (
        			USR02 as USR02
        	) on
        		UST04.BNAME = USR02.BNAME
        distinct
        {
            UST04.BNAME,
            USR02.USTYP,
            P15.PROFN,
            P15.TYPE,
            P15.OBJCT,
            P15.AUTH,
            P15.ACT_ID,
            P15.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------
    	/*This view shows the Auth single role matches. This is done by connecting SCAN1_AUTH_P15 to AGR_1016.*/
	view SCAN1_AUTH_P22_ROLE_SINGLE as
		select from SCAN1_AUTH_P20_PROF_UNION as P15
		join (
					AGR_1016 as AGR_1016
			)on
			P15.PROFN = AGR_1016.PROFILE
			distinct{
			AGR_1016.AGR_NAME,
			P15.PROFN,
	    	P15.TYPE,
            P15.OBJCT,
            P15.AUTH,
            P15.ACT_ID,
            P15.GROUP_NUMBER
					};

    //------------------------------------------------------------------------------------------------------
	//This view produces a list of Auth composite role matches.  This si done by joining the results of SCAN1_AUTH_P17 to AGR_AGRS.
	view SCAN1_AUTH_P23_ROLE_COMP as
		select from SCAN1_AUTH_P22_ROLE_SINGLE as P17
		join (
				AGR_AGRS as AGR_AGRS
			)on
			P17.AGR_NAME = AGR_AGRS.CHILD_AGR
		distinct {
			AGR_AGRS.AGR_NAME,
			P17.AGR_NAME "CHILD_AGR",
			P17.PROFN,
	    	P17.TYPE,
            P17.OBJCT,
            P17.AUTH,
            P17.ACT_ID,
            P17.GROUP_NUMBER
		};

    //------------------------------------------------------------------------------------------------------
    //This view is a Union of SCAN1_AUTH_P17 and SCAN1_AUTH_P18 crating a single output table for role matches with a column identifying the type of role.

    view SCAN1_AUTH_P24_ROLE_UNION as
        select from SCAN1_AUTH_P22_ROLE_SINGLE as P17 distinct
        {
    P17.AGR_NAME,
    'SINGLE_ROLE' "TYPE",
    P17.OBJCT,
    P17.AUTH,
    P17.ACT_ID,
    P17.GROUP_NUMBER
        }
    union
        select from SCAN1_AUTH_P23_ROLE_COMP as P18   distinct
        {
    P18.AGR_NAME,
    'COMP_ROLE' "TYPE",
    P18.OBJCT,
    P18.AUTH,
    P18.ACT_ID,
    P18.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------	
	//This view is a Union of SCAN1_AUTH_P15, SCAN1_AUTH_P16 and SCAN1_AUTH_P19.  This view provides an output 
	//of all profile, user and role auth matches, providing in one view all the objects that have an activity auth match.  
	//The column OBJECT_TYPE has been added to identify the type of object for each record.  The column OBJECT_SUB_TYPE has 
	//been pulled from the type column in the source views to provide the object sub type for each record. 
    view SCAN1_AUTH_P25_ALL as
        select from SCAN1_AUTH_P20_PROF_UNION as P20 distinct
        {
            P20.PROFN "OBJECT_ID",
            'PROF' "OBJECT_TYPE",
            P20.TYPE "OBJECT_SUB_TYPE",
            P20.OBJCT,
            P20.AUTH,
            P20.ACT_ID,
            P20.GROUP_NUMBER
        }
    union
        select from SCAN1_AUTH_P21_USERS as P21      distinct
        {
            P21.BNAME "OBJECT_ID",
            'USER' "OBJECT_TYPE",
            P21.USTYP "OBJECT_SUB_TYPE",
            P21.OBJCT,
            P21.AUTH,
            P21.ACT_ID,
            P21.GROUP_NUMBER
        }
    union
        select from SCAN1_AUTH_P24_ROLE_UNION as P24 distinct
        {
            P24.AGR_NAME "OBJECT_ID",
            'ROLE' "OBJECT_TYPE",
            P24.TYPE "OBJECT_SUB_TYPE",
            P24.OBJCT,
            P24.AUTH,
            P24.ACT_ID,
            P24.GROUP_NUMBER
        };
        
    //------------------------------------------------------------------------------------------------------

    //SCAN TCODE----------------------------------------------------------------------------------------------------------------------------------------------------


    //SCAN TCODE PREP---------------------------------------------------------------------------------------
/*View to add an extra VON column into UST12 which displays only those values listed left of
  	the first * found the VON string.  The * is included as well.
  		
  	This is required to cater for those older versions of SAP which allowed invalid combinations of
  	wild cards that would cause issues with the fuzzy matching logic.*/

    view SCAN1_TCODE_P00_UST12_CONVERT_P01 as
        select from UST12 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            left("VON", (locate("VON", '*'))) "VON_LEFT_OF_STAR",
            A1.BIS
        }
        where
                OBJCT =    'S_TCODE'
            and VON   like '%*%'
    union
        select from UST12 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON "VON_LEFT_OF_STAR",
            A1.BIS
        }
        where
                OBJCT =        'S_TCODE'
            and VON   not like '%*%';

    //------------------------------------------------------------------------------------------------------
/*View to add an extra BIS column into UST12 which displays only those values listed left of
  	the first * found the BIS string.  The * is included as well.
  		
  	This is required to cater for those older versions of SAP which allowed invalid combinations of
  	wild cards that would cause issues with the fuzzy matching logic.*/

    view SCAN1_TCODE_P00_UST12_CONVERT_P02 as
        select from SCAN1_TCODE_P00_UST12_CONVERT_P01 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.BIS,
            left("BIS", (locate("BIS", '*'))) "BIS_LEFT_OF_STAR"
        }
        where
            BIS like '%*%'
    union
        select from SCAN1_TCODE_P00_UST12_CONVERT_P01 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.BIS,
            A1.BIS "BIS_LEFT_OF_STAR"
        }
        where
               BIS not like '%*%'
            or BIS is       null;

    //-------------------------------------------------------------------
/*View to add an extra VON column into UST12 where all * values have been replaces with a % */
/*This is required to make the fuzzy matching logic to work*/

    view SCAN1_TCODE_P00_UST12_CONVERT_P03 as
        select from SCAN1_TCODE_P00_UST12_CONVERT_P02 as A1
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            replace("VON_LEFT_OF_STAR", '*', '%') "VON_WILD_CARD",
            A1.BIS,
            A1.BIS_LEFT_OF_STAR
        };

    //------------------------------------------------------------------------------------------------------
/*View to add an extra TCODE_VON column into ACT_TCODE where all * values have been replaces with a %
    		This is required to make the fuzzy matching logic to work.*/

    view SCAN1_TCODE_P00_ACT_TCODE_CONVERT as
        select from ACT_TCODE as A2
        {
            A2.ACT_ID,
            A2.ACTIVE,
            'S_TCODE' "TCODE_OBJCT",
            A2.TCODE_VON,
            replace("TCODE_VON", '*', '%') "TCODE_VON_WILD_CARD",
            A2.TCODE_BIS,
            A2.GROUP_NUMBER
        }
        where
            ACTIVE = true;

    //------------------------------------------------------------------------------------------------------

    //SCAN TCODE SCAN-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------

/*View produces a list of matches between a record in SCAN1_TCODE_P00_ACT_AUTH_CONVERT and SCAN1_TCODE_P00_UST12_CONVERT_P03. */

/*SCAN1_TCODE_P00_UST12_CONVERT_P03 and SCAN1_TCODE_P00_ACT_AUTH_CONVERT are joined on FIELD in SCAN1_TCODE_P00_UST12_CONVERT_P03
    		and FIELD in ACT_AUTH as well as OBJCT in UST12 and OBJECT in SCAN1_TCODE_P00_ACT_AUTH_CONVERT.  Different where clauses are then used
     		in each select in the UNION to produce different types of matches required*/

/*This is a UNION that combines 3 different queries*/

/*This select in the UNION produces all matches that occur from a range values and direct matches.
     		The where clause takes the TCODE_VON value from SCAN1_TCODE_P00_ACT_AUTH_CONVERT and checks
     		if it between VON_LEFT_OF_STAR and BIS_LEFT_OF_STAR in SCAN1_TCODE_P00_UST12_CONVERT_P03 or,
     		if the VON_LEFT_OF_STAR value from SCAN1_TCODE_P00_UST12_CONVERT_P03 is between TCODE_VON and
     		AUTH_VALUES_BIS in SCAN1_TCODE_P00_ACT_AUTH_CONVERT this produces all range matches.
     		The where clause also checks if TCODE_VON in SCAN1_TCODE_P00_ACT_AUTH_CONVERT is equal to
     		VON_LEFT_OF_STAR is SCAN1_TCODE_P00_UST12_CONVERT_P03 producing all the direct value matches.*/

    view SCAN1_TCODE_P01_ALL_MATCHES as
        select from SCAN1_TCODE_P00_UST12_CONVERT_P03 as A1
        join (
                    SCAN1_TCODE_P00_ACT_TCODE_CONVERT as A2
        )                                                   on
            A1.OBJCT = A2.TCODE_OBJCT
        distinct
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1."VON_WILD_CARD",
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,
            A2.ACT_ID,
            A2.TCODE_OBJCT,
            A2.TCODE_VON,
            A2.TCODE_VON_WILD_CARD, //This is the converted VON field for the fuzzy matching
            A2.TCODE_BIS,
            A2.GROUP_NUMBER
        }
        where
            (
                (
                    (A2."TCODE_VON")        between A1."VON_LEFT_OF_STAR" and A1."BIS_LEFT_OF_STAR"
                )
            )
            or (
                (
                    (A1."VON_LEFT_OF_STAR") between A2."TCODE_VON" and A2."TCODE_BIS"
                )
            )
            or (
                (
                    A2.TCODE_VON            =       A1.VON_LEFT_OF_STAR
                )
            )
    union

        /*This select in the UNION produces a list of matches where the VON value in UST12 contains a wildcard value “*”
        	and where the BIS value for UST12 is null removing any ranges from the list of matches.  The Where clause then checks
        	and returns matches where the TCODE_VON value in SCAN1_TCODE_P00_ACT_TCODE_CONVERT is like VON_WILD_CARD (the converted VON field)
        	in SCAN1_TCODE_P00_ACT_TCODE_CONVERT producing all fuzzy matching records where a wildcard is used in UST12.

        	The where clause also checks if the VON value in UST12 is equal to “*” returning all matches that occur due to the VON value in UST12
        	being listed as “*” */

        select from SCAN1_TCODE_P00_UST12_CONVERT_P03 as A1
        join (
                    SCAN1_TCODE_P00_ACT_TCODE_CONVERT as A2
        )                                                   on
            A1.OBJCT = A2.TCODE_OBJCT
        distinct
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.VON_WILD_CARD,
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,
            A2.ACT_ID,
            A2.TCODE_OBJCT,
            A2.TCODE_VON,
            A2.TCODE_VON_WILD_CARD, //This is the converted VON field for the fuzzy matching
            A2.TCODE_BIS,
            A2.GROUP_NUMBER
        }
        where
            (
                    A1.VON       like '%*%'
                and A1.BIS       is   null
                and A2.TCODE_VON like A1.VON_WILD_CARD
            )
            or (
                    A1.VON       =    '*'
            )
    union

        /*This select in the UNION produces a list of matches where the VON value in ACT_AUTH contains a wildcard value “*”
          	and where the BIS value for ACT_AUTH is null removing any ranges from the list of matches.  The Where clause then checks
          	and returns matches where the VON value in UST12 is like VON% (the converted VON field) in ACT_AUTH producing all fuzzy matching
          	records where a wildcard is used in ACT_AUTH.

          	The where clause also checks if the VON value in ACT_AUTH is equal to “*” returning all matches that occur due to the VON value in ACT_AUTH being listed as “*” */

/*This select in the UNION produces a list of matches where the VON value in ACT_TCODE contains a wildcard value “*”
 	and where the TCODE_BIS value for ACT_TCODE is null removing any ranges from the list of matches.  The Where clause then checks
 	and returns matches where the VON_LEFT_OF_STAR value in SCAN1_TCODE_P00_UST12_CONVERT_P03 is like TCODE_VON_WILD_CARD
 	(the converted VON field) in SCAN1_TCODE_P00_ACT_TCODE_CONVERT producing all fuzzy matching records where a wildcard is used in ACT_TCODE.

 	The where clause also checks if the VON value in ACT_TCODE is equal to “*” returning all matches that occur due to the VON value in ACT_TCODE
 	being listed as “*” */


        select from SCAN1_TCODE_P00_ACT_TCODE_CONVERT as A2
        join (
                    SCAN1_TCODE_P00_UST12_CONVERT_P03 as A1
        )                                                   on
            A2.TCODE_OBJCT = A1.OBJCT
        distinct
        {
            A1.OBJCT,
            A1.AUTH,
            A1.FIELD,
            A1.VON,
            A1.VON_LEFT_OF_STAR,
            A1.VON_WILD_CARD,
            A1.BIS,
            A1.BIS_LEFT_OF_STAR,
            A2.ACT_ID,
            A2.TCODE_OBJCT,
            A2.TCODE_VON,
            A2.TCODE_VON_WILD_CARD, //This is the converted VON field for the fuzzy matching
            A2.TCODE_BIS,
            A2.GROUP_NUMBER
        }
        where
            (
                    A2.TCODE_VON        like '%*%'
                and A2.TCODE_BIS        is   null
                and A1.VON_LEFT_OF_STAR like A2.TCODE_VON_WILD_CARD
            )
            or (
                    A2.TCODE_VON        =    '*'
            );

    //------------------------------------------------------------------------------------------------------
	//This view produces a list of AUTH ACT TCODE matches providing the activity and group the AUTH has a TCODE match to.  
    
    view SCAN1_TCODE_P02_TCODE_MATCH as
        select from SCAN1_TCODE_P01_ALL_MATCHES as P1 distinct
        {
            P1.OBJCT,
            P1.AUTH,
            P1.ACT_ID,
            P1.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------

    //SCAN TCODE TO PROFILE-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
	//This view joins the true TCODE matches from SCAN1_TCODE_P02 to the corresponding Single Profile in UST10S.  
	//This is done by joining the OBJCT and AUTH values between the two tables.  
    
    view SCAN1_TCODE_P03_SINGLE_PROF as
        select from SCAN1_TCODE_P02_TCODE_MATCH as P2
        join (
                    UST10S as UST10S
        )                                             on
                P2.OBJCT = UST10S.OBJCT
            and P2.AUTH  = UST10S.AUTH
        distinct
        {
            UST10S.PROFN "SINGLE_PROFN",
            P2.OBJCT,
            P2.AUTH,
            P2.ACT_ID,
            P2.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------
	//This view joins UST10C to the results of SCAN1_TCODE_P03 producing the list of composite profile matches.  
    
    view SCAN1_TCODE_P04_COMP_PROF as
        select from SCAN1_TCODE_P03_SINGLE_PROF as P3
        join (
                    UST10C as UST10C
        )                                             on
            P3.SINGLE_PROFN = UST10C.SUBPROF
        distinct
        {
            UST10C.PROFN "COMP_PROFN",
            P3.SINGLE_PROFN,
            P3.OBJCT,
            P3.AUTH,
            P3.ACT_ID,
            P3.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------
	//This view is a Union of SCAN1_TCODE_P03 and SCAN1_TCODE_P04 creating a single output table for profile TCODE matches with a column identifying the type of profile.

	view SCAN1_TCODE_P05_PROF_UNION as
		select from SCAN1_TCODE_P03_SINGLE_PROF as P3
		distinct{
		    P3.SINGLE_PROFN "PROFN",
		    'SINGLE_PROF' "TYPE",
            P3.OBJCT,
            P3.AUTH,
            P3.ACT_ID,
            P3.GROUP_NUMBER
		}

	union
	
		select from SCAN1_TCODE_P04_COMP_PROF as P4
		distinct{
		    P4.COMP_PROFN "PROFN",
		    'COMP_PROF' "TYPE",
            P4.OBJCT,
            P4.AUTH,
            P4.ACT_ID,
            P4.GROUP_NUMBER
		};

    //------------------------------------------------------------------------------------------------------
	//This view shows the User Activity TCODE matches.  This is done by joining SCAN1_AUTH_P05 to UST04.  
	//The user type is also added into the view by joining UST04 and USR02.  
    
    view SCAN1_TCODE_P06_USERS as
    	select from SCAN1_TCODE_P05_PROF_UNION as P5
    	join (
    				UST04 as UST04
    			)on
    			P5.PROFN = UST04.PROFILE
    	join (
    				USR02 as USR02
    			)on
    				UST04.BNAME = USR02.BNAME
    	distinct{
    		UST04.BNAME,
    		USR02.USTYP,
    		P5.PROFN,
            P5.TYPE,
            P5.OBJCT,
            P5.AUTH,
            P5.ACT_ID,
            P5.GROUP_NUMBER
    	
    	};

    //------------------------------------------------------------------------------------------------------
    //This view shows the TCODE single role matches. This is done by connecting SCAN1_TCODE_P05 to AGR_1016.
    view SCAN1_TCODE_P07_ROLE_SINGLE as
    select from SCAN1_TCODE_P05_PROF_UNION as P5
    join (
                AGR_1016 as AGR_1016
    )                                            on
        P5.PROFN = AGR_1016.PROFILE
    distinct
    {
        AGR_1016.AGR_NAME,
        P5.PROFN,
        P5.TYPE,
        P5.OBJCT,
        P5.AUTH,
        P5.ACT_ID,
        P5.GROUP_NUMBER
    };

    //------------------------------------------------------------------------------------------------------
	//This view produces a list of TCODE composite role matches.  This is done by joining the results of SCAN1_AUTH_P17 to AGR_AGRS.

	view SCAN1_TCODE_P08_ROLE_COMP as
		select from SCAN1_TCODE_P07_ROLE_SINGLE as P7
		join (
				AGR_AGRS as AGR_AGRS
			)on
			P7.AGR_NAME = AGR_AGRS.CHILD_AGR
		distinct {
			AGR_AGRS.AGR_NAME,
			P7.AGR_NAME "CHILD_AGR",
			P7.PROFN,
	    	P7.TYPE,
            P7.OBJCT,
            P7.AUTH,
            P7.ACT_ID,
            P7.GROUP_NUMBER
		};
		
    //------------------------------------------------------------------------------------------------------
	//This view is a Union of SCAN1_TCODE_P07 and SCAN1_TCODE_P08 crating a single output table for role matches with a column identifying the type of role.
	    view SCAN1_TCODE_P09_ROLE_UNION as
    select from SCAN1_TCODE_P07_ROLE_SINGLE as P7 distinct
    {
        P7.AGR_NAME,
        'SINGLE_ROLE' "TYPE",
        P7.OBJCT,
        P7.AUTH,
        P7.ACT_ID,
        P7.GROUP_NUMBER
    }
    union
    select from SCAN1_TCODE_P08_ROLE_COMP as P8   distinct
    {
        P8.AGR_NAME,
        'COMP_ROLE' "TYPE",
        P8.OBJCT,
        P8.AUTH,
        P8.ACT_ID,
        P8.GROUP_NUMBER
    };
    
    //------------------------------------------------------------------------------------------------------
    //This view is a Union of SCAN1_TCODE_P05, SCAN1_TCODE_P06 and SCAN1_TCODE_P09.  
    //This view provides an output of all profile, user and role TCODE matches, providing in one view all the objects that have an activity TCODE match.  
    //The column OBJECT_TYPE has been added to identify the type of object for each record.  The column OBJECT_SUB_TYPE has been pulled from the type column in the source views to provide the object sub type for each record. 
    
    view SCAN1_TCODE_P10_ALL as
    	select from SCAN1_TCODE_P05_PROF_UNION as P5 distinct
    	{
    	    P5.PROFN "OBJECT_ID",
            'PROF' "TYPE",
            P5.TYPE "SUB_TYPE",
            P5.OBJCT,
            P5.AUTH,
            P5.ACT_ID,
            P5.GROUP_NUMBER
    	}
    union
        select from SCAN1_TCODE_P06_USERS as P6       distinct
        {
            P6.BNAME "OBJECT_ID",
            'USER' "TYPE",
            P6.USTYP "SUB_TYPE",
            P6.OBJCT,
            P6.AUTH,
            P6.ACT_ID,
            P6.GROUP_NUMBER
        }
    union    
        select from SCAN1_TCODE_P09_ROLE_UNION as P9 distinct
        {
            P9.AGR_NAME "OBJECT_ID",
            'ROLE' "OBJECT_TYPE",
            P9.TYPE "OBJECT_SUB_TYPE",
            P9.OBJCT,
            P9.AUTH,
            P9.ACT_ID,
            P9.GROUP_NUMBER
        };

    //------------------------------------------------------------------------------------------------------

    //SCAN 2 PREP-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
   //This view is a union of ACT_AUTH and ACT_TCODE providing a full list of ACT_ID and GROUP_NUMBER values to be used in scan 2.  
    view SCAN2_P00_ACT_ALL as
        select from ACT_AUTH as ACT_AUTH   distinct
        {
            ACT_ID,
            GROUP_NUMBER
        }
    union
        select from ACT_TCODE as ACT_TCODE distinct
        {
            ACT_ID,
            GROUP_NUMBER
        }
        order by
            ACT_ID,
            GROUP_NUMBER;

    //------------------------------------------------------------------------------------------------------

    //SCAN 2 USERS-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
	//This view uses the Scan 2 prep view and joins it to SCAN1_AUTH_P16 (AUTH match view) and SCAN1_TCODE_P06 (TCODE match view) on ACT_ID and GROUP_NUMBER.  
	//A where clause is then used to ensure the BNAME and USTYP from are the same from the AUTH match view and the TCODE match view.  
	//This then provides a list of user activity group matches where the user has the activity because they have both the authorisation and transaction to execute the activity. 
    
    view SCAN2_P01_USER_ACT as
        select from SCAN2_P00_ACT_ALL as ACT_ALL
        left outer join (
                    SCAN1_AUTH_P21_USERS as P16
        )                                      on
                ACT_ALL.ACT_ID       = P16.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P16.GROUP_NUMBER
        left outer join (
                    SCAN1_TCODE_P06_USERS as P6
        )                                      on
                ACT_ALL.ACT_ID       = P6.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P6.GROUP_NUMBER
        distinct
        {
            ACT_ALL.ACT_ID,
            ACT_ALL.GROUP_NUMBER,
            P16.BNAME "USER_ID",
            P16.USTYP "USER_TYPE"
        }
        where
            P16.BNAME = P6.BNAME
            and P16.USTYP = P6.USTYP;

    //------------------------------------------------------------------------------------------------------

    //SCAN 2 PROF-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
	//This view uses the Scan 2 prep view and joins it to SCAN1_AUTH_P15 (AUTH match view) and SCAN1_TCODE_P05 (TCODE match view) on ACT_ID and GROUP_NUMBER.  
	//A where clause is then used to ensure the PROFN and TYPE are the same from the AUTH match view and the TCODE match view.  
	//This then provides a list of profile activity group matches where the profile has the activity because it has both the authorisation and transaction to execute the activity. 

    view SCAN2_P02_PROF_ACT as
        select from SCAN2_P00_ACT_ALL as ACT_ALL
        left outer join (
                    SCAN1_AUTH_P20_PROF_UNION as P15
        )                                      on
                ACT_ALL.ACT_ID       = P15.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P15.GROUP_NUMBER
        left outer join (
                    SCAN1_TCODE_P05_PROF_UNION as P5
        )                                      on
                ACT_ALL.ACT_ID       = P5.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P5.GROUP_NUMBER
        distinct
        {
            ACT_ALL.ACT_ID,
            ACT_ALL.GROUP_NUMBER,
            P15.PROFN "PROF_ID",
            P15.TYPE "PROF_TYPE"
        }
        where
                P15.PROFN     = P5.PROFN
            and P15.TYPE = P5.TYPE;

    //------------------------------------------------------------------------------------------------------

    //SCAN 2 ROLE-------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
	//This view uses the Scan 2 prep view and joins it to SCAN1_AUTH_P19 (AUTH match view) and SCAN1_TCODE_P09 (TCODE match view) on ACT_ID and GROUP_NUMBER.  
	//A where clause is then used to ensure the AGR_NAME and TYPE are the same from the AUTH match view and the TCODE match view.  
	//This then provides a list of role activity group matches where the role has the activity because it has both the authorisation and transaction to execute the activity. 

    view SCAN2_P03_ROLE_ACT as
        select from SCAN2_P00_ACT_ALL as ACT_ALL
        left outer join (
                    SCAN1_AUTH_P24_ROLE_UNION as P19
        )                                             on
                ACT_ALL.ACT_ID       = P19.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P19.GROUP_NUMBER
        left outer join (
                    SCAN1_TCODE_P09_ROLE_UNION as P9
        )                                             on
                ACT_ALL.ACT_ID       = P9.ACT_ID
            and ACT_ALL.GROUP_NUMBER = P9.GROUP_NUMBER
        distinct
        {
            ACT_ALL.ACT_ID,
            ACT_ALL.GROUP_NUMBER,
            P19.AGR_NAME "ROLE_ID",
            P19.TYPE "TYPE"
        }
        where
            P19.AGR_NAME = P9.AGR_NAME
            and P19.TYPE = P9.TYPE;


    //------------------------------------------------------------------------------------------------------
	//This view is a union of SCAN2_P01, SCAN2_P02 and SCAN2_P03 providing a full list of object activity matches.  
	//Columns have been added to identify the object type and object sub type within the full output list. 

    view SCAN2_P04_FULL as
        select from SCAN2_P02_PROF_ACT as PROF distinct
        {
            PROF.ACT_ID,
            PROF.GROUP_NUMBER,
            PROF.PROF_ID "OBJECT_ID",
            'PROF' "OBJECT_TYPE",
            PROF.PROF_TYPE "OBJECT_SUB_TYPE"
        }
    union
        select from SCAN2_P03_ROLE_ACT as ROLE         distinct
        {
            ROLE.ACT_ID,
            ROLE.GROUP_NUMBER,
            ROLE.ROLE_ID "OBJECT_ID",
            'ROLE' "OBJECT_TYPE",
            ROLE.TYPE "OBJECT_SUB_TYPE"
        }
    union
        select from SCAN2_P01_USER_ACT as USER     distinct
        {
            USER.ACT_ID,
            USER.GROUP_NUMBER,
            USER.USER_ID "OBJECT_ID",
            'USER' "OBJECT_TYPE",
            USER.USER_TYPE "OBJECT_SUB_TYPE"
        };

    //------------------------------------------------------------------------------------------------------

    //SCAN 3 -------------------------------------------------------------------------------------------------------------------------------------------------

    //------------------------------------------------------------------------------------------------------
	
	
	
	
	//Work in Progress
	
	//Connects all OBJECT activty TCODE matches back to their TCODES 
    view SCAN3_P01_TCODE_MATCH_ALL as
        select from SCAN1_TCODE_P10_ALL as P10
        join (
                    SCAN1_TCODE_P01_ALL_MATCHES as P01
        )                                          on
            P10.AUTH = P01.AUTH
            and P10.ACT_ID = P01.ACT_ID
            and P10.GROUP_NUMBER = P01.GROUP_NUMBER
        distinct
        {
           P01.ACT_ID,
           P01.GROUP_NUMBER,
           P10.OBJECT_ID,
           P10.TYPE,
           P10.SUB_TYPE,
           P10.OBJCT,
           P01.TCODE_VON,
           P01.TCODE_VON_WILD_CARD,
           P01.TCODE_BIS
        };
		
		//Ensures only the tcodes matches that are part of a match where the auth is also true are only displayed. 
		view SCAN3_P02_TCODE_MATCH_ONLY as
        select from SCAN3_P01_TCODE_MATCH_ALL as TCODE_ALL
        join (
                    SCAN2_P04_FULL as P04
        )                                          on
					TCODE_ALL.ACT_ID = P04.ACT_ID
					and TCODE_ALL.GROUP_NUMBER = P04.GROUP_NUMBER
					and TCODE_ALL.OBJECT_ID = P04.OBJECT_ID
				distinct
				{
				P04.ACT_ID,
				P04.GROUP_NUMBER,
				P04.OBJECT_ID,
				P04.OBJECT_TYPE,
				P04.OBJECT_SUB_TYPE,
				TCODE_ALL.TCODE_VON,
				TCODE_ALL.TCODE_VON_WILD_CARD,
				TCODE_ALL.TCODE_BIS
				};
	
	//Brings the test activity data into the view for analysis. 
	view SCAN3_P03_TCODE_ACTIVITY_RISK_TCODE as
	select from TEST_ACTIVITY as TEST_ACTIVITY
	join (
				SCAN3_P02_TCODE_MATCH_ONLY as P00
				)								on
				TEST_ACTIVITY.ACT_ID = P00.ACT_ID
				and TEST_ACTIVITY.TCODE_VON = P00.TCODE_VON
			distinct
			{
			TEST_ACTIVITY.TST_ID,
			TEST_ACTIVITY.ACT_ID,
			TEST_ACTIVITY.GROUP_NUMBER,
			P00.OBJECT_ID,
			P00.OBJECT_TYPE,
			P00.OBJECT_SUB_TYPE,
			P00.TCODE_VON,
			P00.TCODE_BIS
			};
	
	
		//Performs a count on tcode to be compared to a count perofrmed on tcode on the test activity table. 
	    view SCAN3_P04_TCODE_ACTIVITY_RISK_TCODE_COUNT as
        select from SCAN3_P03_TCODE_ACTIVITY_RISK_TCODE as P00
        {
            P00.TST_ID,
			P00.ACT_ID,
			P00.GROUP_NUMBER,
			P00.OBJECT_ID,
			P00.OBJECT_TYPE,
			P00.OBJECT_SUB_TYPE,
			count(P00.TCODE_VON) as TCODE_COUNT
        }
        group by
            P00.TST_ID,
			P00.ACT_ID,
			P00.GROUP_NUMBER,
			P00.OBJECT_ID,
			P00.OBJECT_TYPE,
			P00.OBJECT_SUB_TYPE;
	
	
	
		//Provides a count of TCODE on TEST activity to compare the count from SCAN3_P04_TCODE_ACTIVITY_RISK_TCODE_COUNT to
		view SCAN3_P05_TEST_ACTIVITY_TCODE_COUNT as 
		select from TEST_ACTIVITY as TEST_ACTIVITY
		{
		TEST_ACTIVITY.TST_ID,
		TEST_ACTIVITY.ACT_ID,
		TEST_ACTIVITY.GROUP_NUMBER,
		count(TEST_ACTIVITY.TCODE_VON) as TCODE_COUNT
		}
		group by 
			TEST_ACTIVITY.TST_ID,
			TEST_ACTIVITY.ACT_ID,
			TEST_ACTIVITY.GROUP_NUMBER;
	
		//Matches the two TCODE count tables to produce a list of records that have the correct number of TCODEs in the test activity group. 
		view SCAN3_P06_TCODE_COUNT_MATCH as
		select from SCAN3_P04_TCODE_ACTIVITY_RISK_TCODE_COUNT as P01
		join (
				SCAN3_P05_TEST_ACTIVITY_TCODE_COUNT as P02
				)	on
				P01.TST_ID = P02.TST_ID
				and P01.ACT_ID = P02.ACT_ID
				and P01.GROUP_NUMBER = P02.GROUP_NUMBER
				and P01.TCODE_COUNT = P02.TCODE_COUNT
			{
			P01.TST_ID,
			P01.ACT_ID,
			P01.GROUP_NUMBER,
			P01.OBJECT_ID,
			P01.OBJECT_TYPE,
			P01.OBJECT_SUB_TYPE
			};
			
			
			
		//Performs a count of number of activities per group in a test to compare to a count performed on the maches.
		view SCAN3_P07_TEST_ACTIVITY_GROUP_ACT_COUNT as
		select from TEST_ACTIVITY as TEST_ACTIVITY
		{
		TEST_ACTIVITY.TST_ID,
		TEST_ACTIVITY.GROUP_NUMBER,
		count(TEST_ACTIVITY.ACT_ID) as ACT_COUNT
		}
		group by
		TEST_ACTIVITY.TST_ID,
		TEST_ACTIVITY.GROUP_NUMBER;
		
		//Performs a count of the number of activities per goup in the match results per test and gorup. 
		view SCAN3_P08_TCODE_COUNT_MATCH_ACT_COUNT as
		select from SCAN3_P06_TCODE_COUNT_MATCH as P00
		{
			P00.TST_ID,
			P00.GROUP_NUMBER,
			P00.OBJECT_ID,
			P00.OBJECT_TYPE,
			P00.OBJECT_SUB_TYPE,
			count(P00.ACT_ID) as ACT_COUNT
		}
		group by
			P00.TST_ID,
			P00.GROUP_NUMBER,
			P00.OBJECT_ID,
			P00.OBJECT_TYPE,
			P00.OBJECT_SUB_TYPE;
			
		
		view SCAN3_P09_ACT_COUNT_MATCH as
		select from SCAN3_P08_TCODE_COUNT_MATCH_ACT_COUNT as P01
		join (
				SCAN3_P07_TEST_ACTIVITY_GROUP_ACT_COUNT as P02
				) on
				P01.TST_ID = P02.TST_ID
				and P01.GROUP_NUMBER = P02.GROUP_NUMBER
				and P01.ACT_COUNT = P02.ACT_COUNT
			{
			P01.TST_ID,
			P01.GROUP_NUMBER,
			P01.OBJECT_ID,
			P01.OBJECT_TYPE,
			P01.OBJECT_SUB_TYPE
			};
			
		VIEW SCAN3_P10_ACT_MATCH_TCODE_LIST as
		select from SCAN3_P03_TCODE_ACTIVITY_RISK_TCODE as P01
		join (
				SCAN3_P09_ACT_COUNT_MATCH as P02
				) on
				P01.TST_ID = P02.TST_ID
				and P01.OBJECT_ID = P02.OBJECT_ID
				and P01.OBJECT_TYPE = P02.OBJECT_TYPE
				and P01.OBJECT_SUB_TYPE = P02.OBJECT_SUB_TYPE
				and P01.GROUP_NUMBER = P02.GROUP_NUMBER
				distinct
			{
			P01.TST_ID,
			P01.ACT_ID,
			P01.GROUP_NUMBER,
			P01.OBJECT_ID,
			P01.OBJECT_TYPE,
			P01.OBJECT_SUB_TYPE,
			P01.TCODE_VON,
			P01.TCODE_BIS
			};
			
			
	//End Work in progress
	
	
	
	
	
	
	
	
	//This view provides a count of the number of activities within a test.  
	//This is to be used in in scan 3 to identify where an object has the correct number of activity matches within a test for a match to occur. 
    
    view SCAN3_P01_TEST_COUNT as
        select from TEST_ACTIVITY as TEST_ACTIVITY distinct
        {
            TEST_ACTIVITY.TST_ID,
            count(TEST_ACTIVITY.ACT_ID) as ACT_COUNT
        }
        group by
            TEST_ACTIVITY.TST_ID;

    //------------------------------------------------------------------------------------------------------
	//This view joins SCAN2_P04 and TEST_ACTIVITY on ACT_ID producing a list of activity matches with the activities corresponding test assigned against each record. 

    view SCAN3_P02_ACT_DISTINCT as
        select from SCAN2_P04_FULL as SCAN2
        join (
                    TEST_ACTIVITY as TEST_ACTIVITY
        )                                          on
            SCAN2.ACT_ID = TEST_ACTIVITY.ACT_ID
        distinct
        {
            TEST_ACTIVITY.TST_ID,
            SCAN2.ACT_ID,
            SCAN2.OBJECT_ID,
            SCAN2.OBJECT_TYPE,
            SCAN2.OBJECT_SUB_TYPE
        }
        order by
            TST_ID,
            OBJECT_ID,
            ACT_ID;


    //------------------------------------------------------------------------------------------------------
	//This view performs a count on ACT_ID from SCAN3_P02 to then provide a count to be compared to SCAN3_P01 to identify test matches. 
	
    view SCAN3_P03_ACT_COUNT as
        select from SCAN3_P02_ACT_DISTINCT as P2 distinct
        {
            P2.TST_ID,
            count(P2.ACT_ID)   as ACT_ID_COUNT,
            P2.OBJECT_ID,
            P2.OBJECT_TYPE,
            P2.OBJECT_SUB_TYPE
        }
        group by
            P2.TST_ID,
            P2.OBJECT_ID,
            P2.OBJECT_TYPE,
            P2.OBJECT_SUB_TYPE;

    //------------------------------------------------------------------------------------------------------
	//This view joins SCAN3_P03 and SCAN3_P01 on TST_ID and activity count to produce all object test matches. 
	
    view SCAN3_P04_MATCH as
        select from SCAN3_P03_ACT_COUNT as P3
        join (
                    SCAN3_P01_TEST_COUNT as P1
        )                                      on
                P3.TST_ID       = P1.TST_ID
            and P3.ACT_ID_COUNT = P1.ACT_COUNT
        distinct
        {
            P1.TST_ID,
            P3.OBJECT_ID,
            P3.OBJECT_TYPE,
            P3.OBJECT_SUB_TYPE
        };
};